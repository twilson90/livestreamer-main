package.path = (debug.getinfo(1,"S").source:match([[^@?(.*[\/])[^\/]-$]]) or "./").."?.lua;"..package.path
local ON_WINDOWS = (package.config:sub(1,1) ~= '/')
local tmp_dir = ON_WINDOWS and os.getenv('TEMP') or (os.getenv('TMP') or '/tmp/')

local assdraw = require("mp.assdraw")
local options = require("mp.options")
local _msg = require("mp.msg")
local utils = require("mp.utils")
local io = require("io")
local base64 = require("base64")
local md5 = require("md5")
-- local ytdl_hook = require("ytdl_hook")

-- mp.enable_messages()

local unpack = unpack or table.unpack
local _listeners = {}
local MAX_EDL_REPEATS = 1024

local LUAON = {}

local __tostring = tostring
tostring = function(s)
    local t = type(s)
    s = __tostring(s)
    -- prevents scientific notation (2e-12) being used to express numbers
    if t == "number" and s:find("e") then
        s = string.format("%f", s)
        s = s:gsub(".(0+)$", "")
    end
    return s
end

LUAON.stringify = function(o)
    local t = type(o)
    if t == "table" then
        local s = {}
        local length = #o
        for i=1,length do
            table.insert(s, LUAON.stringify(o[i]))
        end
        for k,v in pairs(o) do
            if type(k) ~= "number" or k > length then
                table.insert(s, "["..LUAON.stringify(k).."]="..LUAON.stringify(v))
            end
        end
        return "{"..table.concat(s, ",").."}"
    elseif t == "string" then
        return '"'..o:gsub('"','\\"')..'"'
    end
    return tostring(o)
end

LUAON.parse = function(str)
    local cb,err = load("return "..str)
    if err then msg.error(err) end
    return cb and cb()
end

local JSON = {}

JSON.stringify = function(t)
    local json, error = utils.format_json(t)
    return json
end

JSON.parse = function(t)
    local data, error = utils.parse_json(t)
    return data
end

-------------------------------------------------------

local msg = (function()
    local d = {}
    function log(level,...)
        local parts = table.pack(...)
        for i=1,parts.n do
            if type(parts[i]) ~= "string" then parts[i] = LUAON.stringify(parts[i]) end
        end
        _msg.log(level, table.concat(parts," "))
    end
    for _,t in ipairs({"fatal","error","warn","info","verbose","debug","trace"}) do
        d[t]=function(...)
            log(t,...)
        end
    end
    return d
end)()

-------------------------------------------------------

function tostring_or_nil(v)
    if v == nil then return nil end
    return tostring(v)
end

local array = {}
array.map = function(array, func)
    local mapped = {}
    for i,v in ipairs(array) do
        table.insert(mapped, func(v,i))
    end
    return mapped
end

array.filter = function(array, func)
    local filtered = {}
    for i,v in ipairs(array) do
        if func(v,i) then
            table.insert(filtered, v)
        end
    end
    return filtered
end

array.contains = function(array, val)
    for _,value in ipairs(array) do
        if value == val then
            return true
        end
    end

    return false
end

array.push = function(t, ...)
    local args = table.pack(...)
    for i=1,args.n do
        table.insert(t, args[i])
    end
end

array.find_index = function(t,o)
    local is_delegate = type(o) == "function"
    for i,v in ipairs(t) do
        if (is_delegate and o(v)) or v == o then return i end
    end
    return 0
end

array.find = function(t,o)
    return t[array.find_index(t,o)]
end

-----------------------------

if not table.pack then
    table.pack = function(...) return { n = select("#", ...), ... } end
end

table.assign = function(table, ...)
    for _,t in ipairs({...}) do
        for k,v in pairs(t) do
            table[k] = v
        end
    end
    return table
end

table.copy = function(t) -- shallow-copy a table
    local meta = getmetatable(t)
    local target = {}
    for k, v in pairs(t) do target[k] = v end
    setmetatable(target, meta)
    return target
end

table.entries = function(t)
    local a = {}
    for k,v in pairs(t) do table.insert(a, {k,v}) end
    return a
end

table.values = function(t)
    local a = {}
    for k,v in pairs(t) do table.insert(a, v) end
    return a
end

table.keys = function(t)
    local a = {}
    for k,v in pairs(t) do table.insert(a, k) end
    return a
end

table.from_keys = function(keys)
    local t = {}
    for _,k in ipairs(keys) do
        t[k]=1
    end
    return t
end

---------------------------------

string.hash = function(str)
    local m = md5.new()
    m:update(str)
    return md5.tohex(m:finish())
end

string.split = function(s, delim)
    local fields = {}
    local pattern = string.format('([^%s]+)', delim)
    s:gsub(pattern, function(c) table.insert(fields, c) end)
    return fields
end

string.trim = function(s)
    return s:match("^%s*(.-)%s*$")
end

string.format2 = function(s, tab)
    return (s:gsub('($%b{})', function(w) return tab[w:sub(3, -2)] or "nil" end))
end

function deep_copy(orig, copies)
    copies = copies or {}
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        if copies[orig] then
            copy = copies[orig]
        else
            copy = {}
            copies[orig] = copy
            for orig_key, orig_value in next, orig, nil do
                copy[deep_copy(orig_key, copies)] = deep_copy(orig_value, copies)
            end
            setmetatable(copy, deep_copy(getmetatable(orig), copies))
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function deep_equals(o1, o2)
    return LUAON.stringify(o1) == LUAON.stringify(o2)
end

function basename(path)
    local dirname,filename = utils.split_path(path)
    return filename
end

function dirname(path)
    local dirname,filename = utils.split_path(path)
    return dirname
end

function unix_path(path)
    if ON_WINDOWS then path = path:gsub('\\','/') end
    return path
end

function join_paths(s, ...)
    for _,t in ipairs({...}) do
        s = utils.join_path(s, t)
    end
    if ON_WINDOWS then s = s:gsub('/','\\') else s = s:gsub('\\','/') end
    return s
end

function write_file(path, str)
    local file = io.open(path, "w")
    file:write(str)
    file:close()
end

function read_file(path)
    local file = io.open(path, "r")
    local s = file:read("*a")
    file:close()
    return s
end

function file_exists(path)
    path = file_uri_to_path(path)
    local res = utils.file_info(path)
    return to_boolean(res and res.is_file)
end

function dir_exists(path)
    path = file_uri_to_path(path)
    local res = utils.file_info(path)
    return to_boolean(res and res.is_dir)
end

function exists(path)
    path = file_uri_to_path(path)
    return to_boolean(utils.file_info(path))
end

function create_dir(path)
    local cmd
    if ON_WINDOWS then
      cmd = {'cmd', '/c', 'mkdir', path}
    else
      cmd = {'mkdir', '-p', path}
    end
    a = exec(cmd)
    msg.info("create_dir:",a)
  end

function get_ext(str)
    local ext = str:match("[^.]+$")
    if ext then ext = ext:lower() end
    return ext
end

function edl_escape(url)
    return "%"..string.len(url).."%"..url
end

function av_escape(url)
    return url:gsub("'", [['\\\'']]):gsub(":", "\\%0")
end

function to_boolean(v)
    if v then return true else return false end
end

function iif(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

function to_yes_or_no(v)
    if v then return "yes" else return "no" end
end

function clamp(num, min, max)
    return math.min(max, math.max(min, num))
end

function loop(num, min, max)
    local len = max-min
    num = min + (len ~= 0 and math.fmod(num-min, len) or 0)
    if num < min then num = num + len end
    return num
end

function decode_uri(s)
    return s:gsub("+", " "):gsub('%%(%x%x)', function(code) return string.char(tonumber(code, 16)) end)
end

function file_uri_to_path(uri)
    if uri:sub(1, 7) ~= 'file://' then
        return uri
    end
    local rest = decode_uri(uri:sub(8))
    local firstSlash = rest:find('/')
    local host = rest:sub(1, firstSlash-1)
    local path = rest:sub(firstSlash+1)
    if host == 'localhost' then host = '' end
    if host ~= "" then host = "//" .. host end
    path = path:gsub("^(.+)%|", '%1:')
    if ON_WINDOWS then path = path:gsub('\\','/') end
    -- if not windows path...
    if not path:find("^.+:") then path = "/" .. path end
    return host .. path
end

-----------------------------------------------------------

function on(type, fn)
    if not _listeners[type] then _listeners[type] = {} end
    table.insert(_listeners[type], fn)
end

function once(type, fn)
    local to = nil
    local temp = nil
    temp = function(...)
        off(type, temp)
        if to then
            to:kill()
        end
        fn(...)
    end
    on(type, temp)
end

function off(type, fn)
    if not _listeners[type] then _listeners[type] = {} end
    for i=#_listeners[type],1,-1 do
        if _listeners[type][i] == fn then table.remove(_listeners[type], i) end
    end
end

function dispatch(type, ...)
    if not _listeners[type] then _listeners[type] = {} end
    for i,p in ipairs(_listeners[type]) do p(...) end
end

-----------------------------------------------------------

local PLAYER_PROPS
local PLAYER_DEFAULT_PROPS
local FILE_PROPS

local settings = {
    -- ["socket"] = "",
}
options.read_options(settings, "livestreamer", function(changes)
    msg.info("options changed:", changes)
end)
msg.info("settings:", settings)

local video_exts = {"3g2","3gp","aaf","asf","avchd","avi","drc","flv","gif","m2v","m4p","m4v","mkv","mng","mov","mp2","mp4","mpe","mpeg","mpg","mpv","mxf","nsv","ogg","ogv","qt","rm","rmvb","roq","svi","vob","webm","wmv","yuv"}
local is_encoding = mp.get_property_native("o") ~= ""
local idle_mode = mp.get_property_native("idle")
msg.info("idle_mode:", idle_mode)
local end_on_eof = mp.get_property_native("end-on-eof")
msg.info("is_encoding:", is_encoding)
local media_cache = {}
local initialized = false

local mpv_props = {}

local default_observes = {
    -- ["stream-path"] = 1,
    -- ["path"] = 1,
    ["stream-open-filename"] = 1,
    ["volume"] = 1,
    ["duration"] = 1,
    ["time-pos"] = 1,
    ["pause"] = 1,
    ["deinterlace"] = 1,
    ["track-list"] = 1,
    ["estimated-vf-fps"] = 1,
    ["interpolation"] = 1,
    -- ["playlist"] = 1,
    -- ["playlist-pos"] = 1,
    -- ["playlist-pos-1"] = 1,
    -- ["playlist-count"] = 1,
    -- ["af"] = 1,
    -- ["vf"] = 1,
    -- ["aid"] = 1,
    -- ["vid"] = 1,
    -- ["lavfi-complex"] = 1,
    -- ["seekable"] = 1,
    -- ["idle-active"] = 1,
    -- ["eof-reached"] = 1,
    -- ["fps"] = 1,
    -- ["core-idle"] = 1,
    -- ["paused-for-cache"] = 1,
    -- ["demuxer-via-network"] = 1,
    -- ["video-frame-info"] = 1,
}

local ignore_property_change_log = {
    ["time-pos"] = 1,
    ["duration"] = 1,
    ["estimated-vf-fps"] = 1,
    -- ["estimated-display-fps"] = 1,
    -- ["video-frame-info"] = 1,
}

local _rebuild_filters = false
local _rebuild_lavfi_complex_filter = false
local init_opts = {}
local S = {}
local current_item = nil
local loaded_item = nil
local last_item = nil
local last_video_filter_graph = ""
local last_audio_filter_graph = ""
local last_lavfi_hash = ""
local default_fps = 30
local init_stream_open_filename = nil
local fake_observes = {}

local osd
local script_path = debug.getinfo(1, "S").source
local logo_path = join_paths(dirname(script_path), "assets", "logo.png")

-- default playres is 384x288 (use this for positioning subs relative to screen)
local ass_template = [[
[Script Info]
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 384
PlayResY: 288

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: livestreamer-default,${font},${size},${color},${color},${outline_color},${shadow_color},${bold},${italic},${underline},0,100,100,${spacing},0,1,${outline_thickness},${shadow_depth},${alignment},${margin},${margin},${margin},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,${start},${end},livestreamer-default,,0,0,0,,${text}
]]

-----------------------------------------------------------

function exec(args)
    return mp.command_native({name = "subprocess", args = args, capture_stdout = true, capture_stderr = true, playback_only = false})
end

function get_media_info(file)
    if not media_cache[file] then
        local p = exec({"ffprobe", '-show_streams', '-show_format', '-print_format', 'json', file})
        media_cache[file] = JSON.parse(p.stdout)
    end
    return media_cache[file]
end

function get_mpv_media_info(file)
    local p,err = exec({'mpv', '--frames=0', '--vo=null', '--ao=null', '--script='..join_paths(dirname(script_path), 'get_media_info.lua'), file})
    if p.status ~= 0 then
        return nil
    end
    local _,json
    for s in p.stdout:gmatch("[^\r\n]+") do
        _,_,json = s:find("^%[get_media_info%] (.-)%s*$")
        if json then break end
    end
    local info = JSON.parse(trim(json))
    return info
end

function set_osd(res_x, res_y, text)
    if osd == nil then
        osd = mp.create_osd_overlay("ass-events")
    end
    if osd.res_x == res_x and osd.res_y == res_y and osd.data == text then
        return
    end
    osd.res_x = res_x
    osd.res_y = res_y
    osd.data = text
    osd.z = 1000
    osd:update()
end

function reload(options)
    if not loaded_item then return end
    options = table.assign({
        start=get_time_pos(),
        pause=mpv_props["pause"],
    }, options)
    msg.info("reloading current item...")
    set_playlist_id(loaded_item.id, options)
end

function get_time_pos()
    if not loaded_item then return 0 end
    local t = mpv_props["time-pos"] or loaded_item.options.start
    if loaded_item.options.is_special then
        t = t + loaded_item.options.start
    end
    return t
end

function seek(time_pos)
    if not loaded_item or not loaded_item.seekable then return end
    if loaded_item.options.is_special then
        set_property("_special-seeking", true)
        set_playlist_id(loaded_item.id, {
            is_special=true,
            reload_props=false,
            start=time_pos,
            pause=mpv_props["pause"],
        })
    else
        mp.commandv("seek", time_pos, "absolute+exact")
    end
end

function register_script_message(name, cb)
    mp.register_script_message(name, function(json)
        local args = JSON.parse(json)
        cb(unpack(args))
    end)
end

function get_dimensions()
    local t = {}
    if S.core["stream-method"] == "gui" then
        -- t = { get_property("display-width"), get_property("display-height") }
        -- returns 3840 1080 with dual screens :/
    elseif S.core["stream-resolution"] then
        for m in S.core["stream-resolution"]:gmatch("%d+") do
            t[#t+1] = tonumber(m)
        end
    end
    if #t == 0 then
        t = {1920,1080}
    end
    return t[1], t[2]
end

-- pad or crop
function create_scale_filter(w, h, pad)
    w = tostring(w)
    h = tostring(h)
    local f = "scale=(iw*sar)*min("..w.."/(iw*sar)\\,"..h.."/ih):ih*min("..w.."/(iw*sar)\\,"..h.."/ih)"
    if pad then
        f = f..":force_original_aspect_ratio=decrease,pad="..w..":"..h..":("..w.."-iw*min("..w.."/iw\\,"..h.."/ih))/2:("..h.."-ih*min("..w.."/iw\\,"..h.."/ih))/2"
    else
        f = f..":force_original_aspect_ratio=increase,crop="..w..":"..h
    end
    return f
end

function ass_text(text)
    return text:gsub("\r?\n", "\\N")
end

function ass_fade(fade)
    fade = tonumber(fade) or 0
    if fade > 0 then
        return "{\\fad("..tostring(fade*1000)..","..tostring(fade*1000)..")}"
    end
    return ""
end

function ass_rotate(x,y,z)
    return "{\\frx"..tostring(x or 0).."}{\\fry"..tostring(y or 0).."}{\\frz"..tostring(-(z or 0)).."}"
end

function ass_time(a)
    local h = math.floor(a/(60*60*1000))
    a = a - h*(60*60*1000)
    local m = math.floor(a/(60*1000))
    a = a - m*(60*1000)
    local s = math.floor(a/1000)
    a = a - s*1000
    a = math.floor(a/10)
    return string.format("%d:%02d:%02d.%02d",h,m,s,a)
end

function ass_color(color) -- rrggbbaa
    color = tostring(color):gsub("^0x", ""):gsub("^#", ""):upper()
    local parts = {}
    if #color == 8 then
        table.insert(parts, dec_to_hex(255-tonumber(color:sub(7,8),16)))
    end
    -- ass color is in BBGGRR or AABBGGRR format
    table.insert(parts, color:sub(5,6))
    table.insert(parts, color:sub(3,4))
    table.insert(parts, color:sub(1,2))
    return "&H"..table.concat(parts,"")
end

function dec_to_hex(IN)
    local B,K,OUT,I,D=16,"0123456789ABCDEF","",0
    while IN>0 do
        I=I+1
        IN,D=math.floor(IN/B),math.fmod(IN,B)+1
        OUT=string.sub(K,D,D)..OUT
    end
    return OUT
end

function rebuild_filters()
    if not loaded_item then return end

    _rebuild_filters = false

    local vf_graph = {}
    local af_graph = {}
    
    local fps = tonumber(mpv_props["_force-fps"])
    if fps ~= nil and fps ~= 0 and fps > 0 then
        table.insert(vf_graph, "fps="..tostring(fps))
    end

    local left = tonumber(mpv_props["_crop-left"]) or 0
    local right = tonumber(mpv_props["_crop-right"]) or 0
    local top = tonumber(mpv_props["_crop-top"]) or 0
    local bottom = tonumber(mpv_props["_crop-bottom"]) or 0
    if left ~= 0 or right ~= 0 or top ~= 0 or bottom ~= 0 then
        msg.info("crop:", {left=left, right=right, top=top, bottom=bottom})
        local crop_filter = string.format('crop=w=iw*%f:h=ih*%f:x=iw*%f:y=ih*%f', math.abs(1-right-left), math.abs(1-bottom-top), left, top)
        table.insert(vf_graph, crop_filter)
    end
    
    local fade_in, fade_out = get_fade_in_out()
    local special_start_time = tonumber(mpv_props["_special-start-time"]) or 0
    local end_fade = loaded_item.duration - fade_out - 0.5
    
    if fade_in ~= 0 and special_start_time == 0 then
        table.insert(vf_graph, "fade=t=in:st=0:d="..tostring(fade_in))
        table.insert(af_graph, "afade=t=in:st=0:d="..tostring(fade_in))
    end
    if fade_out ~= 0 and end_fade >= 0 and loaded_item.duration > 0 then
        table.insert(vf_graph, "fade=t=out:st="..tostring(end_fade)..":d="..tostring(fade_out))
        table.insert(af_graph, "afade=t=out:st="..tostring(end_fade)..":d="..tostring(fade_out))
    end
    
    local norm_method = mpv_props["_volume-normalization"]
    local norm_filters = PLAYER_PROPS["_volume-normalization"].options
    local norm_filter_option = array.find(norm_filters, function(f) return f[1]==norm_method end)
    if norm_filter_option then
        table.insert(af_graph, norm_filter_option[2])
    end
    if is_encoding then
        if mpv_props["_audio-delay"] ~= 0 then
            table.insert(af_graph, "asetpts=PTS+"..tostring(mpv_props["_audio-delay"]).."/TB")
            table.insert(af_graph, "aresample=async=1")
        end
    else
        set_property("audio-delay", mpv_props["_audio-delay"])
    end
    if mpv_props["_audio-channels"] == "mix" then
        table.insert(af_graph, "pan=stereo|c0=.5*c0+.5*c1|c1=.5*c0+.5*c1")
    elseif mpv_props["_audio-channels"] == "left" then
        table.insert(af_graph, "pan=stereo|c0=c0|c1=c0")
    elseif mpv_props["_audio-channels"] == "right" then
        table.insert(af_graph, "pan=stereo|c0=c1|c1=c1")
    end

    vf_graph = table.concat(vf_graph, ",")
    if last_video_filter_graph ~= vf_graph then
        last_video_filter_graph = vf_graph
        if vf_graph == "" then
            mp.commandv("vf", "remove", "@livestreamer")
        else
            mp.commandv("vf", "pre", "@livestreamer:lavfi=["..vf_graph.."]")
        end
    end

    af_graph = table.concat(af_graph, ",")
    if last_audio_filter_graph ~= af_graph then
        last_audio_filter_graph = af_graph
        if af_graph == "" then
            mp.commandv("af", "remove", "@livestreamer")
        else
            -- for afade to work cannot have fix-pts set, it fucks up the timing! ...
            mp.commandv("af", "add", "@livestreamer:lavfi=["..af_graph.."]") -- :fix-pts=yes
        end
    end
end

function rebuild_lavfi_complex_filter()
    if not loaded_item then return end
    _rebuild_lavfi_complex_filter = false

    msg.info("rebuild_lavfi_complex_filter()")

    local lavfi_complex, video_add = get_lavfi_complex()
    local lavfi_hash = string.hash(LUAON.stringify({lavfi_complex, video_add}))
    local is_special = lavfi_complex~=""
    local force_reload = (loaded_item.playback_started and last_lavfi_hash ~= lavfi_hash) or (not loaded_item.playback_started and loaded_item.options.is_special ~= is_special) -- this is such a mess, but by god it works. (nothing else seemingly does!)
    last_lavfi_hash = lavfi_hash
    msg.info("force_reload:", force_reload)

    if force_reload then
        reload({
            is_special=is_special,
            reload_props=false,
        })
        return
    end
    
    if video_add then
        mp.commandv("video-add", unpack(video_add))
    end
    set_property("lavfi-complex", lavfi_complex)
end

function get_lavfi_complex()
    local track_list = loaded_item.init_track_list
    if not track_list then return end

    local video_add = nil
    local vids = 0
    local aids = 0
    local sids = 0
    local albumarts = 0
    local vid = nil
    local has_subs = false
    local background = mpv_props["_background"]
    local background_color = mpv_props["_background-color"]
    local background_file = mpv_props["_background-file"]
    local background_file_start = mpv_props["_background-file-start"]
    local background_file_end = mpv_props["_background-file-end"]
    if not background or background == "" then
        if loaded_item.filename == "livestreamer://intertitle" or loaded_item.filename == "livestreamer://macro" then
            background = "color"
            background_color = "#000000"
        end
        if loaded_item.filename == "livestreamer://empty" then
            background = "default"
        end
    end
    local force_background = background ~= nil
    if background == nil or background == "default" then
        background = S["background"]
        background_color = S["background-color"]
        background_file = S["background-file"]
        background_file_start = S["background-file-start"]
        background_file_end = S["background-file-end"]
    end
    if background ~= "color" then
        background_color = "#000000"
    end

    local artworks = {}

    msg.info("background, force_background:", background, force_background)
    
    for _,t in ipairs(track_list) do
        if t.type == "video" then
            if t.albumart or t["demux-fps"] == 1 then
                albumarts = albumarts + 1
                if (background == "embedded" and not t.external) or (background == "external") then
                    vid = t.id
                end
            end
            vids = vids+1
        elseif t.type == "audio" then
            aids = aids+1
        elseif t.type == "sub" then
            has_subs = true
        end
    end

    if vids > 0 and vids == albumarts and aids == 0 then
        vid = 1
    end

    local has_video = (vids - albumarts) > 0
    local has_audio = aids > 0
    
    -- if loaded_item.is_safe then
    if force_background or (not has_video and not has_subs and not vid) then
        if background == "logo" then
            table.insert(artworks, 1, {
                ["path"]=init_opts["logo_path"]
            })
        end
        if background == "file" then
            table.insert(artworks, 1, {
                ["path"]=background_file,
                ["start"]=background_file_start,
                ["end"]=background_file_end
            })
        end
    end
    -- end
    msg.info("artworks:", artworks)
    
    local artwork, artwork_duration = (function()
        for _,aw in ipairs(artworks) do
            if aw["path"] ~= nil and file_exists(aw["path"]) then
                local mi = get_media_info(aw["path"]) or {}
                if mi.streams and array.find(mi.streams, function(s) return s.codec_type=="video" end) then
                    return aw, tonumber(mi.format.duration) or 0
                end
            end
        end
        return nil, 0
    end)()

    msg.info("artwork, artwork_duration:", artwork, artwork_duration)

    -- need to re do all of this and make it PERFECT. fixed-time-pos, easy to understand, etc.

    if artwork then
        -- if already has video, a still image will have 0 framerate! This is the only way of adding a still image to a media file with video
        local artwork_name = basename(artwork["path"])
        if artwork_duration > 1 then
            local artwork_start = artwork["start"] or 0
            local artwork_end = math.min(artwork["end"] or artwork_duration, artwork_duration)
            local repeats = loaded_item.duration / (artwork_end - artwork_start)
            msg.info("artwork_duration, duration, repeats, artwork_end:", artwork_duration, loaded_item.duration, repeats, artwork_end)
            msg.info("artwork loop time:", (artwork_end - artwork_start))
            -- artwork_duration == 0 or 
            if loaded_item.duration == 0 or repeats == "inf" or repeats > MAX_EDL_REPEATS then
                lavfi = "movie='"..av_escape(unix_path(artwork["path"])).."':loop=0,setpts=N/FRAME_RATE/TB"
                video_add = {"av://lavfi:"..lavfi, "select", artwork_name, "eng", "no"}
                -- weird issue with gifs running way too fast with this method...
            else
                video_add = {edlify({{artwork["path"], ["start"]=artwork_start, ["end"]=artwork_end, ["duration"]=loaded_item.duration}}), "select", artwork_name, "eng", "no"}
            end
        else
            video_add = {artwork["path"], "select", artwork_name, "eng", "yes"}
        end
    end

    msg.info("video_add:", video_add)

    if video_add then
        vid = vids + 1
    end

    local show_waveform = mpv_props["_audio-visualization"] == "waveform"
    local w, h = get_dimensions()
    local fps = tostring(default_fps)
    local lavfi_complex = {}
    local vo = {}
    local vo_info = {}
    local ao = {}
    local ao_info = {}

    local overlay_center = "overlay=x=(main_w-overlay_w)/2:y=(main_h-overlay_h)/2"
    local color_bg = "color=c="..background_color..":s="..tostring(w).."x"..tostring(h)..":r="..fps

    if show_waveform and has_video and not vid then
        vid = 1
    end
    
    if not has_video or force_background or show_waveform then
        array.push(vo, color_bg)
        array.push(vo_info, "COLOR")
        if vid then
            array.push(vo_info, "ALBUMART")
            vo[#vo] = vo[#vo].."[bg1]"
            array.push(vo, 
                "[bg1][vid"..tostring(vid).."]scale2ref=w=oh*mdar:h=ih[bg2][img1]",
                "[bg2][img1]"..overlay_center
            )
        end
        if has_audio and show_waveform then
            array.push(vo_info, "WAVEFORM")
            local wave_w = math.min(1280, w) -- have to cap it at 1280 or it lags!
            local wave_h = math.ceil(wave_w * (h/w))
            local h_scale = 0.5;
            local wf_alpha = 1.0
            local showwaves = "showwaves=mode=line:scale=lin:s="..tostring(wave_w).."x"..tostring(wave_h*h_scale)..":colors=white@"..tostring(wf_alpha)..":r="..fps
            if wave_w ~= w then
                showwaves = showwaves..",scale="..tostring(w)..":-1"
            end
            vo[#vo] = vo[#vo].."[img2]"
            array.push(vo, 
                "[aid1]asplit[ai][ao]",
                "[ai]dynaudnorm,"..showwaves..",fps="..fps.."[wf1]",
                "[wf1][img2]scale2ref=w=oh*mdar:h=ih*"..tostring(h_scale).."[wf2][img3]",
                "[img3][wf2]"..overlay_center
            )
        end
    end

    if not has_audio then
        array.push(ao, "anullsrc=cl=stereo:r=48000")
        array.push(ao_info, "ANULLSRC")
    end

    msg.info("lavfi_complex vo: ["..table.concat(vo_info, " + ").."]")
    msg.info("lavfi_complex ao: ["..table.concat(ao_info, " + ").."]")

    if #vo > 0 then
        array.push(lavfi_complex, table.concat(vo, ";").."[vo]")
    end
    if #ao > 0 then
        array.push(lavfi_complex, table.concat(ao, ";").."[ao]")
    end
    lavfi_complex = table.concat(lavfi_complex, ";")
    
    return lavfi_complex, video_add
end

function get_fade_in_out()
    if not loaded_item then return 0,0 end
    if loaded_item.filename == "livestreamer://intertitle" then
        return tonumber(mpv_props["_title-fade"]) or 0, tonumber(mpv_props["_title-fade"]) or 0
    end
    return tonumber(mpv_props["_fade-in"]) or 0, tonumber(mpv_props["_fade-out"]) or 0
end

function update_value(path, value)
    if type(path) ~= "table" then path = {path} end
    msg.info("update:", table.concat(path, ".").." = "..tostring(value))
    
    local status, res = pcall(function()
        local ref = S
        for i=1,#path-1 do
            if ref[path[i]] == nil then ref[path[i]] = {} end
            ref = ref[path[i]]
        end
        ref[path[#path]] = value
    end)
    
    if status then
        if path[1] == "background" or path[1]:find("^background-") then
            _rebuild_lavfi_complex_filter = true
        end
    else
        msg.info(res)
    end
end

function set_playlist_id(new_id, options)
    msg.info("set_playlist_id", new_id, options)
    last_item = current_item

    if not new_id then new_id = -1 end
    current_item = deep_copy(get_playlist_item(new_id))

    msg.info("current_item:", current_item)

    local empty = {
        filename="livestreamer://empty",
        id=-1,
        index=-1,
        props={},
    }

    if not current_item and S.core["stream-method"] ~= "file" then
        current_item = empty
    end

    options = table.assign({
        pause=false,
        start=0,
        reload_props=true,
        is_special=false,
    }, options)

    local props_on_load = {}
    
    if last_item and new_id == last_item.id then
        props_on_load = last_item.props_on_load
    end
    if options.reload_props or not last_item then
        for k,v in pairs(PLAYER_DEFAULT_PROPS) do
            props_on_load[k] = v.default
        end
        for k,v in pairs(FILE_PROPS) do
            props_on_load[k] = v.default
        end
        for k,v in pairs(S.player_default_override) do
            props_on_load[k] = v
        end
        if current_item then
            for k,v in pairs(current_item.props) do
                props_on_load[k] = v
            end
        end
    end
    msg.info("props_on_load:", props_on_load)

    set_property("_playlist-id", new_id)
    set_property("_loading", true)

    if current_item then
        current_item.options = options
        current_item.props_on_load = props_on_load
    end

    local is_macro = current_item and current_item.filename == "livestreamer://macro"

    if is_macro then
        local func = current_item.props_on_load["_function"]
        if func == "stop" then
            current_item = nil
        elseif func == "handover" then
            -- current_item.filename = "livestreamer://empty"
        end
    end
    if not current_item then
        mp.commandv("stop")
    else
        mp.commandv("loadfile", current_item.filename, "replace")
    end
end

function set_volume(value, immediate)
    set_property("_volume", value)
    if immediate then
        set_property("volume", value)
    end
end

function set_property(name, value)
    if FILE_PROPS[name] ~= nil and current_item then
        current_item.props_on_load[name] = value
    end
    if name:sub(1,1) == "_" then
        if mpv_props[name] ~= value then
            mpv_props[name] = value
            -- don't bother sharing the tons of other fake props... only the important player props.
            if PLAYER_PROPS[name] ~= nil then
                utils.shared_script_property_set("livestreamer-"..name, JSON.stringify(value));
                if fake_observes[name] then
                    for i,callback in ipairs(fake_observes[name]) do
                        msg.info("Set property:", name.."="..tostring(value).." -> 1")
                        callback(name,value)
                    end
                end
            end
        end
    else
        mp.set_property_native(name, value)
    end
end

function get_property(name)
    if name:sub(1,1) ~= "_" then
        mpv_props[name] = mp.get_property_native(name)
    end
    return mpv_props[name]
end

function observe_property(name, cb)
    msg.info("observe_property:", name)
    if name:sub(1,1) == "_" then
        if fake_observes[name] == nil then fake_observes[name] = {} end
        table.insert(fake_observes[name], cb)
    else
        mp.observe_property(name, "native", cb)
    end
end

function table_to_str(t)
    local length = #t
    local s = {}
    for i=1,length do
        table.insert(s, tostring(t[i]))
    end
    for k,v in pairs(t) do
        if type(k) ~= "number" or k > length then
            table.insert(s, tostring(k).."="..tostring(v))
        end
    end
    return table.concat(s,",")
end

function edlify(parts)
    
    msg.info("edlify(parts)", parts)
    local edl_entries = {}
    local total_duration = 0
    for _,part in ipairs(parts) do
        if type(part) == "string" then
            part = {part}
        end
        local force_duration = false
        local clip_start = math.max(0, part["start"] or 0)
        local clip_end = math.max(0, part["end"] or part["duration"] or 0)
        local clip_length = math.max(0, clip_end - clip_start)
        local clip_offset = part["offset"] or 0
        if clip_length < 0.01 then clip_length = 0 end
        local duration = math.max(0, part["duration"] or (clip_length * (part["loops"] or 1)))
        local filename = part["filename"] or part[1]
        if type(filename) == "table" then
            filename = edlify(filename)
        end

        msg.info("part:", part)
        msg.info("part clipping:", {clip_start, clip_end, clip_length, clip_offset})

        local files = {}
        if filename then
            filename = file_uri_to_path(filename)
            filename = edl_escape(filename)
            local get_start = function() return loop(clip_start + clip_offset, clip_start, clip_end) end
            local t = get_start();
            if clip_length == 0 then
                array.push(files, {filename, t})
            else
                --[[ local d_left = duration
                local i = 0
                msg.info("duration:", duration)
                while d_left > 0 and i < MAX_EDL_REPEATS do
                    local s = i > 0 and clip_start or first_clip_start
                    local d = clamp(clip_end - s, 0, d_left)
                    array.push(files, {filename, s, d})
                    d_left = d_left - d
                    i = i + 1
                end ]]
                local d_left = duration
                local i = 0
                if clip_length ~= 0 then
                    while d_left > 0 and i < MAX_EDL_REPEATS do
                        local e = math.min(t + clip_length, t + d_left, clip_end)
                        local d = e-t;
                        array.push(files, {filename, t, d})
                        d_left = d_left - d
                        i = i + 1
                        if e == clip_end then t = clip_start end
                    end
                end
                --[[ local d_left = duration
                local i = 0
                while d_left > 0.01 and i < MAX_EDL_REPEATS do
                    local s = i == 0 and first_clip_start or clip_start
                    local d = clamp(clip_end - s, 0, d_left)
                    array.push(files, {filename, s, d})
                    d_left = d_left - d
                    i = i + 1
                end ]]
            end
        end
        -- if #files>1 and part["edl"] then
        --     files = {edl_escape("edl://"..table.concat(array.map(files, function(f) return table_to_str(f) end),";"))}
        --     --[[ if part["delay_open"] then
        --         if duration == 0 then
        --             msg.warn("duration cannot be 0 with !delay_open header present:", part)
        --         end
        --         array.push(files[1], 0, duration)
        --     end ]]
        -- end
        for _,v in ipairs({"new_stream", "no_clip", "delay_open", "mp4_dash", "global_tags", "no_chapters"}) do
            if part[v] then
                local header = {"!"..v}
                if type(part[v]) == "table" then table.assign(header, part[v]) end
                array.push(edl_entries, table_to_str(header))
            end
        end
        for _,file in ipairs(files) do
            for _,v in ipairs({"title", "timestamps"}) do
                if part[v] then
                    file[v] = part[v]
                end
            end
            array.push(edl_entries, table_to_str(file))
        end
        total_duration = total_duration + duration
    end

    if #edl_entries>0 then
        return "edl://"..table.concat(edl_entries,";"), total_duration
    end

    return nil, 0

end

function get_playlist_items(id, recursive)
    local playlist = {}
    local children = array.filter(table.values(S.playlist), function(item) return item.parent_id == id end)
    table.sort(children, function(a,b) return a.index<b.index end)
    for _,c in ipairs(children) do
        table.insert(playlist, c)
        if recursive then
            array.push(playlist, unpack(get_playlist_items(c.id, true)))
        end
    end
    return playlist
end

function is_item_playlist(id)
    local item = get_playlist_item(id)
    if not item then return false end
    return #get_playlist_items(id)>0 or item.filename == "livestreamer://playlist"
end

function is_item_timeline(id)
    local item = get_playlist_item(id)
    return item and item.props["_playlist-mode"] == 2
end

function is_item_merged(id)
    local item = get_playlist_item(id)
    return item and item.props["_playlist-mode"] == 1
end

function get_playlist_tracks(id)
    local tracks = {}
    local item = get_playlist_item(id)
    local children = get_playlist_items(id)

    if item then
        table.insert(tracks, {})
        if is_item_timeline(id) then
            table.insert(tracks, {})
        end
    end

    for _,c in ipairs(children) do
        table.insert(tracks[c.track_index+1], c)
    end
    return tracks
end

function get_root_playlist()
    function get_children(id)
        local items = {}
        local children = get_playlist_items(id);
        for _,c in ipairs(children) do
            array.push(items, c);
            if not c.props["_playlist-mode"] then
                array.push(items, unpack(get_children(c.id)));
            end
        end
        return items
    end
    return get_children("0")
end

function get_playlist_item(id)
    return S.playlist[tostring(id)]
end

function get_playlist_item_sibling(id, i)
    local playlist = get_root_playlist()
    local index = array.find_index(playlist, function(i) return i.id == id end) or 0
    local item = playlist[index + i]
    msg.info("get_playlist_item_sibling!!!", id, i)
    msg.info(playlist)
    msg.info(array.map(playlist, function(i) return i.id end))
    msg.info(index)
    if item then msg.info(item.id, item.filename) end
    if item then item = get_playlist_item(item.id) end
    return item
end

function playlist_prev()
    set_playlist_id((get_playlist_item_sibling(current_item.id, -1) or {}).id)
end

function playlist_next()
    set_playlist_id((get_playlist_item_sibling(current_item.id, 1) or {}).id)
end

function init(_init_opts)
    if initialized then return end
    initialized = true
    
    for i,p in ipairs({"start-file","end-file","file-loaded","seek","playback-restart","shutdown","log-message","get-property-reply","set-property-reply","command-reply","client-message","video-reconfig","audio-reconfig","property-change"}) do
        mp.register_event(p, function(...)
            dispatch(p, ...)
        end)
    end

    init_opts = _init_opts
    
    function on_change(k,v)
        mpv_props[k] = v
        if not ignore_property_change_log[k] then
            msg.info("[property-change] "..k.." = "..LUAON.stringify(v))
        end
        if k == "_volume" or k == "_volume-multiplier" then
            -- msg.info("updating volume...")
        end
        if k == "_audio-delay" or k == "_audio-channels" or k == "_volume-normalization" or k == "_force-fps" or k:sub(1,6) == "_crop-" then
            _rebuild_filters = true
        end
        if k == "_audio-visualization" then
            _rebuild_lavfi_complex_filter = true
        end
    end

    PLAYER_PROPS = init_opts.properties.player.props
    PLAYER_DEFAULT_PROPS = init_opts.properties.player_default_override.props
    FILE_PROPS = init_opts.properties.playlist.enumerable_props.props.props

    local observes = deep_copy(default_observes)

    for k,_ in pairs(table.assign({}, PLAYER_PROPS, FILE_PROPS)) do
        if k:sub(1,1) == "_" then
            observes[k] = 1
        end
    end
    
    for k,_ in pairs(observes) do
        on_change(k, get_property(k))
        observe_property(k, on_change)
    end

    mp.add_periodic_timer(1/30, function()
        update()
    end)
end

function quit()
    set_property("idle", false)
    mp.commandv("quit")
end

-----------------------------------------------------------

register_script_message("init", init)
register_script_message("update_value", update_value)
register_script_message("quit", quit)
register_script_message("seek", seek)
register_script_message("reload", reload)
register_script_message("set_property", set_property)
register_script_message("set_volume", set_volume)
register_script_message("set_playlist_id", set_playlist_id)
register_script_message("playlist_next", playlist_next)

function get(func)
    local status, res = pcall(func)
    if status then return res end
end

--[[ function get_props_or_default(item, prop)
    return get(function() return loaded_item.props[prop] or FILE_PROPS[prop].default end)
end ]]

mp.add_hook("on_load", 1, function ()
    init_stream_open_filename = get_property("stream-open-filename")
end)

mp.add_hook("on_load", 50, function ()
    -- local filename = mpv_props["stream-path"]
    local filename = get_property("stream-open-filename")
    -- local is_youtube = init_stream_open_filename ~= filename
    loaded_item = current_item
    
    --necessary as sometimes vid is set to nil before a video starts and it is skipped as a result.
    for k,_ in pairs(FILE_PROPS) do
        set_property(k, loaded_item.props_on_load[k])
    end

    msg.info("mpv_props (on_load):", mpv_props)

    if loaded_item.options.pause ~= nil then
        set_property("pause", loaded_item.options.pause)
    end

    local duration = 0
    local edl_items = nil

    filename, duration, edl_items = (function()
        local file_lookup = {}
    
        -- local null_video_and_audio = "edl://!new_stream;"..edl_escape(init_opts["null_video_path"])..";!new_stream;"..edl_escape(init_opts["null_audio_path"])
        
        local edl_track_types = {"video","audio","sub"}
    
        function _file_exists(filename)
            if not filename then
                return false
            end
            if filename:find("^edl://") then
                return true
            end
            if file_lookup[filename] == nil then
                file_lookup[filename] = file_exists(filename)
            end
            return file_lookup[filename]
        end
    
        function process(id, duration, media_type, is_root, filename)
            local item = get_playlist_item(id)
            local is_playlist = is_item_playlist(id)
            local mi = item and S.media_info[item.filename]
            -- local is_probably_youtube = item and item.filename:find("^https?://") == 1
            local props = (item and item.props) or {}
            filename = filename or (item and item.filename)

            local children = {}
    
            if is_playlist and (is_item_merged(id) or is_item_timeline(id) or not is_root) then

                local tracks = get_playlist_tracks(id)
                local is_timeline = is_item_timeline(id)
        
                local edl = {}
                local edl_tracks = {}
        
                for t,items in ipairs(tracks) do
                    local edl_track = {}
                    edl_track.type = is_timeline and edl_track_types[t] or media_type
                    edl_track.duration = 0
                    for _,item in ipairs(items) do
                        local entry_filename, entry_duration = process(item.id, nil, edl_track.type)
                        if entry_duration > 0 then
                            edl_track.duration = edl_track.duration + entry_duration
                            array.push(edl_track, {entry_filename, ["duration"]=entry_duration})
                            array.push(children, {["id"]=item.id, ["duration"]=entry_duration})
                        end
                    end
                    array.push(edl_tracks, edl_track)
                end
                
                duration = math.max(unpack(array.map(edl_tracks, function(t) return t.duration end)))

                if is_timeline then
                    for _,edl_track in ipairs(edl_tracks) do
                        if (duration - edl_track.duration) > 0.05 then
                            -- add padding to track if necessary
                            local entry_filename, entry_duration = process(nil, duration - edl_track.duration, edl_track.type)
                            array.push(edl_track, {entry_filename, ["duration"]=entry_duration})
                        end
                    end
                end
        
                for _,edl_track in ipairs(edl_tracks) do
                    if #edl_track > 0 then
                        if edl_track.type then
                            array.push(edl, {["new_stream"] = true, ["delay_open"] = {["media_type"]=edl_track.type}})
                        end
                        array.push(edl, unpack(edl_track))
                    end
                end

                if #edl > 0 then
                    filename = edlify(edl)
                end

            elseif not is_root then

                if not _file_exists(filename) then
                    filename = nil
                end
                local stream_map = {}
                local edl = {}
                local temp_dur = duration or props["_clip-end"] or props["_title-duration"] or 60
                local required_stream_types = media_type and {media_type} or {"video","audio"}
                for _,s in ipairs((mi and mi.streams) or {}) do stream_map[s.type] = 1 end
                for _,t in ipairs(required_stream_types) do
                    if not stream_map[t] then
                        array.push(edl, {
                            init_opts["null_"..t.."_path"],
                            ["end"]=init_opts.null_stream_duration,
                            ["duration"]=temp_dur,
                            ["new_stream"]=true
                        })
                    end
                end
                if #edl > 0 then
                    if filename then
                        table.insert(edl, 1, {filename, ["duration"]=temp_dur, ["new_stream"]=true})
                    end
                    
                    table.insert(edl, 1, {["no_chapters"]=true})
                    if not filename then
                        msg.info("EDL-----",edl)
                        msg.info("processed....", edlify(edl))
                    end
                    filename = edlify(edl)
                end
            end
            
            duration = duration or (mi and mi.duration) or 0
            
            if is_root and not _file_exists(filename) then
                -- do nothing
            else
                -- local end_time = props["_clip-end"] or (not is_root and duration or nil)
                if props["_clip-start"] or props["_clip-loops"] or props["_clip-end"] or props["_clip-offset"] or props["_duration"] or not is_root then
                    local edl_part = {
                        filename,
                        ["start"]=props["_clip-start"],
                        ["end"]=props["_clip-end"] or duration,
                        ["loops"]=props["_clip-loops"],
                        ["offset"]=props["_clip-offset"],
                        ["duration"]=props["_duration"],
                    }
                    if is_root then
                        msg.info("edl_part:", edl_part)
                    end
                    filename, duration = edlify({edl_part})
                end
            end

            msg.info(filename, duration, children)
    
            return filename, duration, children
        end
    
        return process(loaded_item.id, nil, nil, true, filename)

    end)()

    loaded_item.duration = duration or 0

    if is_item_playlist(loaded_item.id) and not is_item_merged(loaded_item.id) and not is_item_timeline(loaded_item.id) then
        set_property("stream-open-filename", "")
        return
    end

    if filename and filename:find("^livestreamer://") then
        local livestreamer_path = filename:gsub("^livestreamer://", "")
        filename = "null://"
        if livestreamer_path == "empty" then
            loaded_item.duration = mpv_props["_duration"] or 0
        elseif livestreamer_path == "intertitle" then
            loaded_item.duration = mpv_props["_duration"] or 5
            local ass_data = string.format2(ass_template, {
                ["font"] = mpv_props["_title-font"],
                ["size"] = mpv_props["_title-size"],
                ["color"] = ass_color(mpv_props["_title-color"]),
                ["outline_color"] = ass_color(mpv_props["_title-outline-color"]),
                ["shadow_color"] = ass_color(mpv_props["_title-shadow-color"]),
                ["bold"] = mpv_props["_title-style"]:find("bold") and -1 or 0,
                ["italic"] = mpv_props["_title-style"]:find("italic") and -1 or 0,
                ["spacing"] = mpv_props["_title-spacing"],
                ["outline_thickness"] = mpv_props["_title-outline-thickness"],
                ["shadow_depth"] = mpv_props["_title-shadow-depth"],
                ["alignment"] = mpv_props["_title-alignment"],
                ["underline"] = mpv_props["_title-underline"] and -1 or 0,
                -- ["angle"] = 360-mpv_props["_title-angle"],
                ["margin"] = mpv_props["_title-margin"],
                ["start"] = ass_time(0.25*1000),
                ["end"] = ass_time((math.max(0,loaded_item.duration-0.5))*1000),
                ["text"] = ass_fade(mpv_props["_title-fade"])..(ass_rotate(unpack(mpv_props["_title-rotation"])) or "")..ass_text(mpv_props["_title-text"]),
            })
            msg.info(ass_data)
            filename = "memory://"..ass_data
        elseif livestreamer_path == "rtmp" then
            filename = "rtmp://127.0.0.1:"..init_opts.rtmp_port.."/"..init_opts.live_app.."/"..S.rtmp_key
            -- if localhost port is open and accepts request but stream is not live it breaks mpv completely. Can't figure it out.

            -- filename = "wss://localhost:8112/live/"..S.rtmp_key..".flv"
            -- filename = "https://localhost:8112/live/"..S.rtmp_key..".m3u8"
            -- low-latency profile:

            -- set_property("file-local-options/audio-buffer", 0) -- THIS FUCKS UP RTMP FILES (IF FAIL TO LOAD)
            set_property("file-local-options/vd-lavc-threads", 1)
            set_property("file-local-options/cache-pause", false)
            -- set_property("file-local-options/demuxer-lavf-o", {fflags="+nobuffer"}) -- PROBLEM?
            set_property("file-local-options/demuxer-lavf-probe-info", "nostreams")
            set_property("file-local-options/demuxer-lavf-analyzeduration", 0.1)
            set_property("file-local-options/video-sync", "audio")
            set_property("file-local-options/interpolation", false)
            set_property("file-local-options/video-latency-hacks", true)
            set_property("file-local-options/stream-buffer-size", "4k")
            
            -- I added these for some reason:
            -- set_property("file-local-options/demuxer-lavf-format", "flv")
            -- set_property("file-local-options/demuxer-lavf-buffersize", 8192)
            -- set_property("file-local-options/demuxer-lavf-hacks", true)
        end
    end

    local start_time = loaded_item.options.start

    local seekable = true
    if not filename or filename:find("^rtmp://") or filename:find("^null://") or filename:find("^memory://") then
        seekable = false
        start_time = 0
    end

    local subtitles = mpv_props["_subtitles"]
    local audio = mpv_props["_audio"]

    local special_start_time = 0

    if seekable and loaded_item.options.is_special and start_time ~= 0 then
        special_start_time = start_time
        loaded_item.duration = loaded_item.duration - start_time
        start_time = 0
    end

    if start_time > 0 then
        set_property("file-local-options/start", tostring(start_time))
    end
    
    function try_edlify(filename)
        if special_start_time>0 then
            filename = edlify({{filename, ["start"]=special_start_time}})
        end
        return filename
    end

    filename = try_edlify(filename)

    if subtitles then
        mp.commandv("sub-add", try_edlify(subtitles), "select", basename(subtitles))
    end
    if audio then
        mp.commandv("audio-add", try_edlify(audio), "select", basename(audio))
    end

    set_property("_special-start-time", special_start_time)
    set_property("_edl-items", edl_items)
    set_property("_seekable", seekable)

    loaded_item.seekable = seekable
    if filename ~= mpv_props["stream-open-filename"] then
        set_property("stream-open-filename", filename)
    end

    msg.info("loaded_item:", loaded_item)

    dispatch("on_load")
end)

mp.add_hook("on_preloaded", 50, function ()
    loaded_item.is_preloaded = true
    loaded_item.init_track_list = deep_copy(mpv_props["track-list"])

    if mpv_props["stream-open-filename"]:sub(1,6)=="edl://" then
        -- weird edl bug, streams end but doesn't end. just freezes.
        set_property("file-local-options/end-on-eof", true)
    end
    
    loaded_item.duration = math.max(get_property("duration") or 0, loaded_item.duration or 0)
    msg.info("loaded_item.duration (on_preloaded)", loaded_item.duration)

    -- necessary for items with generated audio or video so they end.
    if loaded_item.duration ~= nil and loaded_item.duration > 0 then
        set_property("file-local-options/end", tostring(loaded_item.duration))
    end

    local only_subs = (#mpv_props["track-list"] == 1 and mpv_props["track-list"][1].type == "sub") or loaded_item.filename == "livestreamer://intertitle"
    if only_subs then
        set_property("sid", 1)
    end
    
    dispatch("preloaded")
    set_property("_loading", false)

    rebuild_filters()
    rebuild_lavfi_complex_filter()
end)

on("shutdown", function(e)
    msg.info("SHUTDOWN!")
end)

on("end-file", function(e)
    loaded_item.eof_reason = e.reason
    msg.info("end-file: (reason="..tostring(e.reason)..")")
end)

on("seek", function(e)
    msg.info("seek:", e)
    if not loaded_item.seekable then
        reload({
            reload_props=false,
        })
    end
end)

on("playback-restart", function()
    set_property("_special-seeking", false)
    if loaded_item then
        loaded_item.playback_started = true
    end
end)

mp.add_hook("on_unload", 10, function ()
    loaded_item.is_preloaded = false
    set_property("_loading", true)
end)

mp.add_hook("on_after_end_file", 10, function ()
    local valid_eof_reasons = {eof=1,error=1,unknown=1}
    if valid_eof_reasons[loaded_item.eof_reason] then
        playlist_next()
    end
end)

-----------------------------------------------------

function update()
    if not loaded_item then return end
    if _rebuild_filters then
        rebuild_filters()
    end
    if _rebuild_lavfi_complex_filter and loaded_item.is_preloaded then
        rebuild_lavfi_complex_filter()
    end
    local volume = tonumber(mpv_props["_volume"]) or 100
    local volume_multiplier = tonumber(mpv_props["_volume-multiplier"]) or 1
    local target_volume = volume * volume_multiplier
    local curr_volume = mpv_props["volume"]
    if curr_volume ~= target_volume then
        local inc = mpv_props["_volume-speed"] or 1
        if inc == 0 then
            curr_volume = target_volume
        else
            if curr_volume < target_volume then
                curr_volume = math.min(curr_volume + inc, target_volume)
            elseif curr_volume > target_volume then
                curr_volume = math.max(curr_volume - inc, target_volume)
            end
        end
        set_property("volume", curr_volume)
    end
end